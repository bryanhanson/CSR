{
  "hash": "dedefa7bae4c298d2bc6ce0658f15d19",
  "result": {
    "markdown": "---\ntitle: \"Notes on Linear Algebra Part 4\"\ndescription: \"A Taxonomy of Matrices\"\ndate: \"2022-09-25\"\ncategories: [R, Linear Algebra]\nformat:\n  html\n---\n\n\nSeries: [Part 1](https://chemospec.org/posts/2022-08-14-Linear-Alg-Notes/2022-08-14-Linear-Alg-Notes.html) [Part 2](https://chemospec.org/posts/2022-09-01-Linear-Alg-Notes-Pt2/Linear-Alg-Notes-Pt2.html) [Part 3](https://chemospec.org/posts/2022-09-10-Linear-Alg-Notes-Pt3/Linear-Alg-Notes-Pt3.html)\n\nBack in Part 2 I mentioned some of the challenges of learning linear algebra.  One of those challenges is making sense of all the special types of matrices one encounters.  In this post I hope to shed a little light on that topic.\n\nI am strongly drawn to thinking in terms of categories and relationships.  I find visual presentations like phylogenies showing the relationships between species very useful.  In the course of my linear algebra study, I came across an interesting Venn diagram developed by the very creative thinker [Kenji Hiranabe](https://github.com/kenjihiranabe/The-Art-of-Linear-Algebra). The diagram is discussed at [Matrix World](https://anagileway.com/2020/09/29/matrix-world-in-linear-algebra-for-everyone/), but the latest version is at the Github link.  A Venn diagram is a useful format, but I was inspired to recast the information in different format.  @fig-flow shows a flowchart I created using a portion of the information in Hiranabe's Venn diagram.[^6]  The flowchart is primarily organized around what I am calling the *structure* of a matrix: what does it look like upon visual inspection (which of course only really works for small matrices)?  To me at least, structure is one of the most obvious characteristics of a matrix: an upper triangular matrix really stands out as something different for instance.  Secondarily, the flowchart includes a number of queries that one can ask about a matrix: for instance, is the matrix invertible?  We'll need to expand on all of this of course, but first take a look at the figure.\n\n\n\n```{mermaid}\n%%| label: fig-flow\n%%| fig-cap: \"Relationships between different types of matrices. *Blue Rectangles* denote matrices with particular, recognizable *structures*.  *Pink Hexagons* indicate properties that can be *queried*.\"\nflowchart TD\nA(all matrices <br/> n x m) --> C(row matrices <br/> 1 x n)\nA --> D(column matrices <br/> n x 1)\nA ---> B(square matrices <br/> n x n)\nB --> E(upper triangular<br/>matrices)\nB --> F(lower triangular<br/>matrices)\nB --> G{{<b>either</b><br/>is singular?}}\nB --> H{{<b>or</b><br/>is invertible?}}\nH --> I{{is diagonalizable?}}\nI --> J{{is normal?}}\nJ --> K(symmetric)\nK --> L(diagonal)\nL --> M(identity)\nJ --> N{{is orthogonal?}}\nN --> M\nstyle G fill:#FFF0F5\nstyle H fill:#FFF0F5\nstyle I fill:#FFF0F5\nstyle J fill:#FFF0F5\nstyle N fill:#FFF0F5\n```\n\n\n# Unpacking the Flowchart\n\n## Structure Examples\n\nLet's use `R` to construct and inspect examples of each type of matrix.  We'll use integers to keep the print output nice and neat, but of course real numbers could be used as well. Most of these are pretty straightforward so we'll we'll keep comments to a minimum for the simple cases.\n\n### Rectangular Matrix $m \\times n$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_rect <- matrix(1:12, nrow = 3) # if you give nrow,\nA_rect # R will compute ncol from the length of the data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n:::\n\n\nNotice that `R` is \"column major\" meaning data fills the first column, then the second column and so forth.\n\n### Row Matrix/Vector $1 \\times m$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_row <- matrix(1:4, nrow = 1) # row matrix/vector\nA_row\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n```\n:::\n:::\n\n\n### Column Matrix/Vector $n \\times 1$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_col <- matrix(1:4, ncol = 1) # column matrix/vector\nA_col\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n```\n:::\n:::\n\n\nKeep in mind that to save space in a text-dense document one would often write `A_col^T` so that the result stays on a line: 1, 2, 3, 4.\n\n### Square Matrix $n \\times n$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_sq <- matrix(1:9, nrow = 3)\nA_sq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\n\n### Upper and Lower Triangular Matrices\n\nCreating a upper triangular matrix requires a few more steps.  Function `upper.tri()` returns a logical matrix which can be used as a mask to select entries.  Function `lower.tri()` can be used similarly.  Both functions have an argument `diag = TRUE/FALSE` indicating whether to include the diagonal values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupper.tri(A_sq, diag = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]  [,2] [,3]\n[1,]  TRUE  TRUE TRUE\n[2,] FALSE  TRUE TRUE\n[3,] FALSE FALSE TRUE\n```\n:::\n\n```{.r .cell-code}\nA_upper <- A_sq[upper.tri(A_sq)]\nA_upper # notice that a vector is returned, not quite what might have been expected!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 7 8\n```\n:::\n\n```{.r .cell-code}\nA_upper <- A_sq # create a copy to be modified\nA_upper[lower.tri(A_upper)] <- 0L # assign the lower entries to zero\nA_upper\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    0    5    8\n[3,]    0    0    9\n```\n:::\n:::\n\nNotice to create an upper triangular matrix we use `lower.tri()` to assign zeros to the lower part of an existing matrix.\n\n### Identity Matrix\n\nIf you give `diag()` a single value it defines the  dimensions and ones are put on the diagonal, giving an identity matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_ident <- diag(4)\nA_ident\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    1    0    0\n[3,]    0    0    1    0\n[4,]    0    0    0    1\n```\n:::\n:::\n\n\n### Diagonal Matrix\n\nIf you give `diag()` a vector of values these go on the diagonal and the length of the vector determines the dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_diag <- diag(1:4)\nA_diag\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    2    0    0\n[3,]    0    0    3    0\n[4,]    0    0    0    4\n```\n:::\n:::\n\n\n### Symmetric Matrices\n\nMatrices created by `diag()` are symmetric matrices, but any matrix where $A_{ij} = A_{ji}$ is symmetric.  There is no general function to create symmetric matrices since there is no way to know what data should be used.  However, one can ask if a matrix is symmetric, using the function `isSymmetric()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisSymmetric(A_diag)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## The Queries\n\nLet's take the queries in the flowchart in order.\n\n### Is the Matrix Singular or Invertible?\n\nA singular matrix is one in which one or more rows are multiples of another row, or alternatively, one or more columns are multiples of another column.  Why do we care? Well, it turns out one cannot do much with a singular matrix.  An invertible matrix however is a very useful entity and has many applications.  What is an invertible matrix?  In simple terms, being invertible means the matrix has an inverse.  This is not the same as the algebraic definition of an inverse, which is related to division:\n\n$$\nx^{-1} = \\frac{1}{x}\n$$\n\nInstead, for matrices, invertibility of $\\mathbf{A}$ is defined as the existence of another matrix $\\mathbf{B}$ such that\n\n$$\n\\mathbf{A}\\mathbf{B} = \\mathbf{B}\\mathbf{A} = \\mathbf{I}\n$$\n\nJust as $x^{-1}$ cancels out $x$ in that $x^{-1}x = \\frac{x}{x} = 1$, $\\mathbf{B}$ cancels out $\\mathbf{A}$ to give the identity matrix.\n\nA singular matrix has a non-zero determinant.  On the other hand, an invertible matrix has a determinant of zero.  So to determine which type of matrix we have before us, we can simply compute the determinant.\n\nLet's look at a few simple examples.\n\n\n+++++++++++++++++++\n\nIn order to explore the queries in the flowchart, it will be helpful to have some formal definitions of the concepts.\n\n\n* The table covers matrices who's elements are $\\in \\mathbb{R}$ (i.e. real numbers).  If working with $\\mathbb{C}$ (complex numbers) there are some additional categories and terminology beyond the real case.\n* *Structure* and *special cases* refer to how the matix *appears* upon simple visual inspection (most obvious for small examples).  Dimensions are given for example as $m \\times n$.\n* *Condition* is a mathematical test/operation that can be applied to the matrix.\n* *Properties* and *eigenvalues* are self-explanatory.\n* *Decomposition* refers to applicable matrix decompositions.  The goal of any decomposition is to recast a matrix in a more usable form. Typical uses are given later.\n* As you move down the taxonomy unfolds: each subsequent row is generally a subset of the prior rows.\n* Conventions: Matrices, including row and column matrices/vectors, will be shown in bold e.g. $\\mathbf{A}$ while scalars and variables will be shown in script, e.g. $n$.\n* The main table should print on a single page if you choose landscape orientation.\n* This document is available at [Github]().\n\n<!-- {{< pagebreak >}} -->\n\n| structure | special cases | condition | properties |\n|:-|:-|:-|:-|:-|\n| all matrices $n \\times m$ | | | |\n| | row matrices $1 \\times m$[^2] | | |\n| | col matrices $n \\times 1$ | | |\n| square matrices $n \\times n$ |  | | |\n| | upper triangular[^4] | | $a_{ij} = 0 \\text{ if } i > j$ |\n| | lower triangular | | $a_{ij} = 0 \\text{ if } i < j$ |\n| $n \\times n$ con't | | **either:** is singular | $\\det(\\mathbf{A}) \\ne 0$ |\n| | | **or:** is invertible | $\\det(\\mathbf{A}) = 0$ |\n| | | is diagonalizable | |\n| | | is normal | $\\mathbf{A}\\mathbf{A}^\\mathsf{T} = \\mathbf{A}^\\mathsf{T}\\mathbf{A} \\ne \\mathbf{I}$ |\n| | symmetric | | $\\mathbf{A} = \\mathbf{A}^\\mathsf{T} \\quad a_{ij} = a_{ji}$[^1] |\n| | diagonal | | $a_{ij} = 0 \\text{ if } i \\ne j$ |\n| | | is orthogonal | $\\mathbf{A}^{-1} = \\mathbf{A}^\\mathsf{T} \\quad \\mathbf{A}\\mathbf{A}^\\mathsf{T} = \\mathbf{A}^\\mathsf{T}\\mathbf{A} = \\mathbf{I}$ |\n| | identity | | $\\mathbf{A}\\mathbf{I} = \\mathbf{I}\\mathbf{A} = \\mathbf{A}$ |\n\n<!-- {{< pagebreak >}} -->\n\n\n\n[^1]: It's helpful to remember that $\\mathbf{A}^\\mathsf{T}\\mathbf{A}$ is always symmetric.\n[^2]: Usually in written text a row matrix, sometimes called a row vector, is written as $\\mathbf{x} = \\begin{bmatrix}1 & 2 & 3\\end{bmatrix}$.  In order to save space in documents, rather than writing $\\mathbf{x} = \\begin{bmatrix}1 \\\\ 2 \\\\ 3\\end{bmatrix}$, a column matrix/vector can be kept to a single line by writing it as its transpose: $\\mathbf{x} = \\begin{bmatrix}1 & 2 & 3\\end{bmatrix}^{\\mathsf{T}}$, but this requires a little mental gymnastics to visualize.\n[^3]: Sometimes this is written $\\mathbf{P}\\mathbf{A} = \\mathbf{L}\\mathbf{U}$ where $\\mathbf{P}$ is a permutation matrix which re-orders the rows of $\\mathbf{A}$.  This is sometimes desirable to avoid near divide-by-zero problems in particular algorithms.\n[^4]: Upper and lower triangular matrices play a special role in linear algebra.  Because of the presence of many zeros, multiplying them and inverting them is relatively easy, because the zeros cause terms to drop out.\n[^5]: A square matrix is non-invertible if any of its rows are multiples of another row, or similarly for columns.  Besides having at least one $\\lambda = 0$, the rank of the matrix is less than the minimum of the number of rows and columns.\n[^6]: I'm only using a portion because the Hiranbe's original contains a bit too much information for someone trying to get their footing in the field.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}