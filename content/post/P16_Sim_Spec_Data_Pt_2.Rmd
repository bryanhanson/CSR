---
title: "Simulating Spectroscopic Data Part 2"
author: "Bryan Hanson"
date: 2020-05-27
tags: ["R", "Simulated Data", "SpecHelpers", "GSOC"]
slug: "P16"
draft: true
---

```{r hiddenSetup, echo = FALSE, eval = TRUE, results = "hide"}
rm(list = ls())
library("knitr")
library("ggplot2")
library("reshape2")
opts_knit$set(echo = TRUE)
```

It is well-recognized that one of the virtues of the `R` language is the extensive tools it provides for working with distributions.  [Functions](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/Distributions) exist to generate random number draws, determine quantiles, and examine the probability [density](https://en.wikipedia.org/wiki/Probability_density_function) and [cumulative](https://en.wikipedia.org/wiki/Cumulative_distribution_function) distribution curves that describe each distribution.

This toolbox gives one the ability to create simulated data sets for testing very easily.  If you need a few random numbers from a Gaussian distribution then `rnorm` is your friend:

```{r rnorm}
rnorm(5)
```

Imagine you were developing a new technique to determine if two methods of manufacturing widgets produced widgets of the same mass.[^1] Even before the widgets were manufactured, you could test your code by simulating widget masses with `rnorm` which picks numbers at random from a Gaussian or normal distribution:

```{r widgets}
widget_1_masses <- rnorm(100, 5.0, 0.5) # mean mass 5.0
widget_2_masses <- rnorm(100, 4.5, 0.5) # mean mass 4.5
```

```{r widgetPlot, echo = FALSE}
DF <- data.frame(Widget_1 = widget_1_masses, Widget_2 = widget_2_masses)
DF2 <- melt(DF)
p <- ggplot(data = DF2, aes(x = value, fill = variable))
p <- p + geom_density(alpha = 0.25) + labs(x = "widget mass by batch")
plot(p)
```

Variations on this approach can be used to simulate spectral data sets.[^2]  The information I will share here is accumulated knowledge.  I have no formal training in the theory behind the issues discussed, only a sense of the applications.  If you see something that is wrong or needs clarification, please use the comments to set me straight!

## Peak Shapes

To get started, we need to know what peak shape to expect for a given type of spectroscopy.  In thinking about this, we should keep in mind that all spectroscopies have some sort of detector, electronic components and basic data processing that can affect peak shape.  A CCD on a UV detector is one of the simpler situations.  FT-IR has a mechanical interferometer, and the raw signal from both IR and NMR is Fourier-transformed prior to use.  So there are not only theoretical issues to think about, but also engineering, instrument tuning, electrical engineering and mathematical issues to consider.  Plus, peaks in UV spectra are broadened by interactions with vibrational states.  Even with these considerations, a Gaussian curve is a good approximation to a simple peak.  However, NMR peaks are typically described as "Lorentzian" which corresponds to the [Cauchy](https://en.wikipedia.org/wiki/Cauchy_distribution) distribution.[@Goldenberg2016]  We'll take a closer look at this in a bit.

If we want to simulate a simple peak with a Gaussian shape, we can use the `dnorm` function:

```{r dnorm1}
x_vals <- seq(-5, 5, length.out = 100)
G1 <- dnorm(x_vals)
plot(x_vals, G1, type = "l")
```

If we want this to look more like a "real" peak, we can increase the x range and use x values with realistic frequency values.  And if we want our spectrum to be more complex, we can add several of these curves together.  Keep in mind that the area under the density curve is 1.0, and the peak width is determined by the value of argument `sd` (the standard deviation).  For example if want to simulate the UV spectrum of [vanillin](https://webbook.nist.gov/cgi/cbook.cgi?ID=C121335&Units=SI&Mask=400), which has maxima at about 230, 280 and 315 nm, one can do something along these lines:

```{r vanillin}
x_vals <- seq(220, 350, by = 1.0)
Peak1 <- dnorm(x_vals, 230, 22)
Peak2 <- dnorm(x_vals, 280, 17)
Peak3 <- dnorm(x_vals, 315, 17)
AllPeaks <- colSums(rbind(1.6 * Peak1, Peak2, Peak3))
plot(x_vals, AllPeaks, type = "l", xlab = "nm", ylab = "arbitrary")
```

The coefficient on `Peak1` is to increase the contribution of that peak in order to better resemble the linked spectrum (note that the linked spectrum y-axis is $log \epsilon$; we're just going for a rough approximation).

 It's a simple, if tedious, task to create several different spectra, and then combine them in various ratios to create a data set representing samples composed of mixtures of compounds.  UV spectra are tougher due to the vibrational coupling; NMR spectra are quite straightforward since we know the area of each magnetic environment in the structure (but we also have to deal with doublets etc.).  If you plan to do a lot of this, take a look at the [`SpecHelpers`](https://cran.r-project.org/package=SpecHelpers) package, which is designed to streamline these tasks.

Let's return to the topic of Gaussian versus Lorentzian (or Cauchy) shaped peaks.  This quick comparison shows that NMR peaks are expected to be less sharp and thus have fatter tails:

```{r GvC}
x_vals <- seq(-5, 5, length.out = 100)
G1 <- dnorm(x_vals)
C1 <- dcauchy(x_vals)
plot(x_vals, G1, type = "l", ylab = "density")
lines(x_vals, C1, col = "red")
```

## Rolling baselines : baseline correction

## Nature of noise several kinds


effect of signal averaging


https://chemistry.stackexchange.com/questions/96064/is-there-a-real-detection-limit-in-nmr-spectroscopy


[`hyperSpec`](https://cran.r-project.org/web/packages/hyperSpec/index.html) is an `R` package for working with hyperspectral data sets.

[Google Summer of Code](https://summerofcode.withgoogle.com/) project to fortify `hyperSpec`.  We are pleased to report that the project was accepted by [R-GSOC](https://github.com/rstats-gsoc/gsoc2020/wiki) administrators, and, as of a few days ago,

[^1]: Of course, this is simply the t-test.

[^2]: For that matter, you can also simulate chromatograms using the methods we are about to show.  It's even possible to introduce tailing of a peak.  For a function to do this, see the [`SpecHelpers`](https://cran.r-project.org/package=SpecHelpers) package.
